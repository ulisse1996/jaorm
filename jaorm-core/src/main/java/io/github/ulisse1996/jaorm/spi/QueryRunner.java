package io.github.ulisse1996.jaorm.spi;

import io.github.ulisse1996.jaorm.ServiceFinder;
import io.github.ulisse1996.jaorm.ResultSetExecutor;
import io.github.ulisse1996.jaorm.UpdateExecutor;
import io.github.ulisse1996.jaorm.entity.EntityDelegate;
import io.github.ulisse1996.jaorm.entity.Result;
import io.github.ulisse1996.jaorm.entity.sql.DataSourceProvider;
import io.github.ulisse1996.jaorm.entity.sql.SqlAccessor;
import io.github.ulisse1996.jaorm.entity.sql.SqlParameter;
import io.github.ulisse1996.jaorm.exception.JaormSqlException;
import io.github.ulisse1996.jaorm.logger.JaormLogger;
import io.github.ulisse1996.jaorm.logger.SqlJaormLogger;
import io.github.ulisse1996.jaorm.mapping.TableRow;
import io.github.ulisse1996.jaorm.spi.common.Singleton;

import java.sql.*;
import java.util.*;
import java.util.stream.Stream;

public abstract class QueryRunner {

    protected static final SqlJaormLogger logger = JaormLogger.getSqlLogger(ResultSetExecutor.class);
    private static final Singleton<QueryRunner> ENTITY_RUNNER = Singleton.instance();
    private static final Singleton<QueryRunner> SIMPLE_RUNNER = Singleton.instance();

    public static QueryRunner getInstance(Class<?> klass) {
        if (!isDelegate(klass)) {
            return getSimple();
        }

        if (!ENTITY_RUNNER.isPresent()) {
            for (QueryRunner runner : ServiceFinder.loadServices(QueryRunner.class)) {
                if (runner.isCompatible(klass)) {
                    ENTITY_RUNNER.set(runner);
                }
            }

            if (ENTITY_RUNNER.isPresent()) {
                return ENTITY_RUNNER.get();
            }
        } else {
            return ENTITY_RUNNER.get();
        }

        throw new IllegalArgumentException("Can't find a matched runner for klass " + klass);
    }

    private static boolean isDelegate(Class<?> klass) {
        return DelegatesService.getInstance().getDelegates().containsKey(klass) ||
                EntityDelegate.class.isAssignableFrom(klass);
    }

    public static QueryRunner getSimple() {
        if (!SIMPLE_RUNNER.isPresent()) {
            for (QueryRunner runner : ServiceFinder.loadServices(QueryRunner.class)) {
                if (runner.isSimple()) {
                    SIMPLE_RUNNER.set(runner);
                }
            }

            if (SIMPLE_RUNNER.isPresent()) {
                return SIMPLE_RUNNER.get();
            }
        } else {
            return SIMPLE_RUNNER.get();
        }

        throw new IllegalArgumentException("Can't find Simple Runner");
    }

    protected int doSimpleUpdate(String query, List<SqlParameter> params) {
        logger.logSql(query, params);
        try (Connection connection = getConnection();
             PreparedStatement preparedStatement = connection.prepareStatement(query);
             UpdateExecutor executor = new UpdateExecutor(preparedStatement, params)) {
            return executor.getUpdateRow();
        } catch (SQLException ex) {
            logger.error("Error during update/insert/delete"::toString, ex);
            throw new JaormSqlException(ex);
        }
    }

    protected Map<String, Object> doUpdate(String query, List<SqlParameter> params, Map<String, Class<?>> autoGenerated) {
        logger.logSql(query, params);
        try (Connection connection = getConnection();
             PreparedStatement preparedStatement = !autoGenerated.keySet().isEmpty()
                     ? connection.prepareStatement(query, autoGenerated.keySet().toArray(new String[0]))
                     : connection.prepareStatement(query);
             UpdateExecutor executor = new UpdateExecutor(preparedStatement, params)) {
            if (executor.getResultSet() != null && executor.getResultSet().next()) {
                Map<String, Object> generated = new HashMap<>();
                for (Map.Entry<String, Class<?>> entry : autoGenerated.entrySet()) {
                    Object value = getGeneratedKey(executor.getResultSet(), entry);
                    generated.put(entry.getKey(), value);
                }
                return generated;
            } else {
                return Collections.emptyMap();
            }
        } catch (SQLException ex) {
            logger.error("Error during update/insert/delete"::toString, ex);
            throw new JaormSqlException(ex);
        }
    }

    private Object getGeneratedKey(ResultSet resultSet, Map.Entry<String, Class<?>> entry) throws SQLException {
        try {
            return SqlAccessor.find(entry.getValue())
                    .getGetter().get(resultSet, entry.getKey());
        } catch (SQLException ex) {
            if (ex.getErrorCode() == 17023) {
                // We try with another approach
                ResultSetMetaData metaData = resultSet.getMetaData();
                for (int i = 0; i < metaData.getColumnCount(); i++) {
                    if (metaData.getColumnName(i + 1).equalsIgnoreCase(entry.getKey())) {
                        return resultSet.getObject(i + 1, entry.getValue());
                    }
                }
            }
            throw ex;
        }
    }

    protected Connection getConnection() throws SQLException {
        DataSourceProvider provider = DataSourceProvider.getCurrent();
        TransactionManager manager = TransactionManager.getInstance();
        if (manager instanceof TransactionManager.NoOpTransactionManager || manager.getCurrentTransaction() == null) {
            return provider.getConnection();
        } else {
            DataSourceProvider delegate = DataSourceProvider.getCurrentDelegate();
            if (delegate == null) {
                DataSourceProvider.setDelegate(manager.createDelegate(provider));
                return DataSourceProvider.getCurrentDelegate().getConnection();
            } else {
                return delegate.getConnection();
            }
        }
    }

    public abstract boolean isCompatible(Class<?> klass);
    public abstract boolean isSimple();

    public abstract <R> R read(Class<R> klass, String query, List<SqlParameter> params);
    public abstract <R> Result<R> readOpt(Class<R> klass, String query, List<SqlParameter> params);
    public abstract <R> List<R> readAll(Class<R> klass, String query, List<SqlParameter> params);
    public abstract <R> Stream<R> readStream(Class<R> klass, String query, List<SqlParameter> params);

    public abstract TableRow read(String query, List<SqlParameter> params);
    public abstract Optional<TableRow> readOpt(String query, List<SqlParameter> params);
    public abstract Stream<TableRow> readStream(String query, List<SqlParameter> params);

    public abstract <R> R insert(R entity, String query, List<SqlParameter> params);
    public abstract int update(String query, List<SqlParameter> params);
    public abstract int delete(String query, List<SqlParameter> params);
}
