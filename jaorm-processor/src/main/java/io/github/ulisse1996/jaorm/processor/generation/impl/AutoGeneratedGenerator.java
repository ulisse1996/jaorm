package io.github.ulisse1996.jaorm.processor.generation.impl;

import com.squareup.javapoet.*;
import io.github.ulisse1996.jaorm.annotation.Column;
import io.github.ulisse1996.jaorm.annotation.CustomGenerated;
import io.github.ulisse1996.jaorm.annotation.CustomGenerator;
import io.github.ulisse1996.jaorm.annotation.TableGenerated;
import io.github.ulisse1996.jaorm.entity.GenerationInfo;
import io.github.ulisse1996.jaorm.entity.converter.ParameterConverter;
import io.github.ulisse1996.jaorm.processor.generation.Generator;
import io.github.ulisse1996.jaorm.processor.util.GeneratedFile;
import io.github.ulisse1996.jaorm.processor.util.ProcessorUtils;
import io.github.ulisse1996.jaorm.spi.GeneratorsService;

import javax.annotation.processing.ProcessingEnvironment;
import javax.annotation.processing.RoundEnvironment;
import javax.lang.model.element.Element;
import javax.lang.model.element.Modifier;
import javax.lang.model.element.TypeElement;
import javax.lang.model.type.MirroredTypeException;
import javax.lang.model.type.TypeMirror;
import java.util.*;
import java.util.stream.Collectors;

public class AutoGeneratedGenerator extends Generator {

    public AutoGeneratedGenerator(ProcessingEnvironment processingEnvironment) {
        super(processingEnvironment);
    }

    @Override
    public void generate(RoundEnvironment roundEnvironment) {
        List<GenerationResult> results = getTableGenerated(roundEnvironment);
        results.addAll(getCustomGenerated(roundEnvironment));
        if (!results.isEmpty()) {
            generateGenerators(results);
        }
    }

    private void generateGenerators(List<GenerationResult> results) {
        TypeSpec generators = TypeSpec.classBuilder("Generators")
                .addModifiers(Modifier.PUBLIC)
                .superclass(GeneratorsService.class)
                .addField(generatorsMap(), "generatorsMap", Modifier.PRIVATE, Modifier.FINAL)
                .addMethod(generatorConstructor(results))
                .addMethod(buildGetGenerators())
                .build();
        ProcessorUtils.generate(processingEnvironment,
                new GeneratedFile(JAORM_PACKAGE, generators, ""));
    }

    private MethodSpec buildGetGenerators() {
        return MethodSpec.overriding(ProcessorUtils.getMethod(processingEnvironment, "getGenerated", GeneratorsService.class))
                .addStatement("return this.generatorsMap")
                .build();
    }

    private MethodSpec generatorConstructor(List<GenerationResult> results) {
        return MethodSpec.constructorBuilder()
                .addModifiers(Modifier.PUBLIC)
                .addCode(constructorCode(results))
                .build();
    }

    private CodeBlock constructorCode(List<GenerationResult> results) {
        Map<TypeElement, List<GenerationResult>> grouped = results
                .stream()
                .collect(Collectors.groupingBy(GenerationResult::getKlass));
        CodeBlock.Builder builder = CodeBlock.builder()
                .addStatement("$T map = new $T<>()", generatorsMap(), HashMap.class);
        for (Map.Entry<TypeElement, List<GenerationResult>> entry : grouped.entrySet()) {
            builder.addStatement("map.put($T.class, new $T<>())", entry.getKey(), ArrayList.class);
            for (GenerationResult result : entry.getValue()) {
                if (result.customGenerator != null) {
                    builder.addStatement("map.get($T.class).add(new $T($S, new $L()))",
                            entry.getKey(), GenerationInfo.class, result.columnName, result.customGenerator);
                } else {
                    builder.addStatement("map.get($T.class).add(new $T($S, $S, $S, $S, $S, $T.$L, null))",
                            entry.getKey(), GenerationInfo.class, result.columnName, result.keyColumn, result.valueColumn,
                            result.matchKey, result.tableName, ParameterConverter.class, result.matchConverter);
                }
            }
        }

        return builder.addStatement("this.generatorsMap = $T.unmodifiableMap(map)", Collections.class)
                .build();
    }

    private TypeName generatorsMap() {
        return ParameterizedTypeName.get(ClassName.get(Map.class),
                ParameterizedTypeName.get(ClassName.get(Class.class), WildcardTypeName.subtypeOf(Object.class)),
                ParameterizedTypeName.get(ClassName.get(List.class), ClassName.get(GenerationInfo.class)));
    }

    private Collection<? extends GenerationResult> getCustomGenerated(RoundEnvironment roundEnvironment) {
        return roundEnvironment.getElementsAnnotatedWith(CustomGenerated.class)
                .stream()
                .map(e -> GenerationResult.fromCustom(e, this.processingEnvironment))
                .collect(Collectors.toList());
    }

    private List<GenerationResult> getTableGenerated(RoundEnvironment roundEnvironment) {
        Set<? extends Element> elementsAnnotatedWith = roundEnvironment.getElementsAnnotatedWith(TableGenerated.class);
        return elementsAnnotatedWith.stream()
                .map(GenerationResult::fromTable)
                .collect(Collectors.toList());
    }

    private static class GenerationResult {

        private TypeElement klass;
        private String tableName;
        private String keyColumn;
        private String valueColumn;
        private String matchKey;
        private ParameterConverter matchConverter;
        private TypeMirror customGenerator;
        private String columnName;

        public TypeElement getKlass() {
            return klass;
        }

        public static GenerationResult fromTable(Element element) {
            TableGenerated generated = element.getAnnotation(TableGenerated.class);
            GenerationResult result = new GenerationResult();
            result.tableName = generated.tableName();
            result.keyColumn = generated.keyColumn();
            result.valueColumn = generated.valueColumn();
            result.matchKey = generated.matchKey();
            result.matchConverter = generated.matchConverter();
            result.klass = (TypeElement) element.getEnclosingElement();
            result.columnName = element.getAnnotation(Column.class).name();
            return result;
        }

        public static GenerationResult fromCustom(Element element, ProcessingEnvironment processingEnvironment) {
            GenerationResult result = new GenerationResult();
            try {
                Class<? extends CustomGenerator<?>> value = element.getAnnotation(CustomGenerated.class).value();
                result.customGenerator = processingEnvironment.getElementUtils().getTypeElement(value.getName())
                        .asType();
            } catch (MirroredTypeException ex) {
                result.customGenerator = ex.getTypeMirror();
            }
            result.klass = (TypeElement) element.getEnclosingElement();
            result.columnName = element.getAnnotation(Column.class).name();
            return result;
        }
    }
}
