package io.github.ulisse1996.jaorm.processor.generation.impl;

import com.squareup.javapoet.ClassName;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.TypeSpec;
import io.github.ulisse1996.jaorm.annotation.Column;
import io.github.ulisse1996.jaorm.annotation.CustomGenerated;
import io.github.ulisse1996.jaorm.annotation.CustomGenerator;
import io.github.ulisse1996.jaorm.annotation.TableGenerated;
import io.github.ulisse1996.jaorm.entity.GenerationInfo;
import io.github.ulisse1996.jaorm.entity.converter.ParameterConverter;
import io.github.ulisse1996.jaorm.processor.generation.Generator;
import io.github.ulisse1996.jaorm.processor.util.GeneratedFile;
import io.github.ulisse1996.jaorm.processor.util.ProcessorUtils;
import io.github.ulisse1996.jaorm.spi.provider.GeneratorProvider;

import javax.annotation.processing.ProcessingEnvironment;
import javax.annotation.processing.RoundEnvironment;
import javax.lang.model.element.Element;
import javax.lang.model.element.Modifier;
import javax.lang.model.element.TypeElement;
import javax.lang.model.type.MirroredTypeException;
import javax.lang.model.type.TypeMirror;
import java.util.*;
import java.util.stream.Collectors;

public class AutoGeneratedGenerator extends Generator {

    public AutoGeneratedGenerator(ProcessingEnvironment processingEnvironment) {
        super(processingEnvironment);
    }

    @Override
    public void generate(RoundEnvironment roundEnvironment) {
        List<GenerationResult> results = getTableGenerated(roundEnvironment);
        results.addAll(getCustomGenerated(roundEnvironment));
        if (!results.isEmpty()) {
            generateGenerators(results);
        }
    }

    private void generateGenerators(List<GenerationResult> results) {
        List<GeneratedFile> files = new ArrayList<>();
        Map<TypeElement, List<GenerationResult>> grouped = results
                .stream()
                .collect(Collectors.groupingBy(GenerationResult::getKlass));
        for (Map.Entry<TypeElement, List<GenerationResult>> entry : grouped.entrySet()) {
            TypeSpec generators = TypeSpec.classBuilder(String.format("%sProvider", entry.getKey().getSimpleName()))
                    .addModifiers(Modifier.PUBLIC)
                    .addSuperinterface(GeneratorProvider.class)
                    .addMethods(getGeneratorMethods(entry.getKey(), entry.getValue()))
                    .build();
            GeneratedFile file = new GeneratedFile(getPackage(entry.getKey()), generators, "");
            ProcessorUtils.generate(processingEnvironment, file);
            files.add(file);
        }

        ProcessorUtils.generateSpi(processingEnvironment, files, GeneratorProvider.class);
    }

    private String getPackage(TypeElement entity) {
        return ClassName.get(entity).packageName();
    }

    private Iterable<MethodSpec> getGeneratorMethods(TypeElement key, List<GenerationResult> value) {
        MethodSpec getEntityClass = MethodSpec.overriding(ProcessorUtils.getMethod(this.processingEnvironment, "getEntityClass", GeneratorProvider.class))
                .addStatement("return $T.class", key)
                .build();

        MethodSpec.Builder builder = MethodSpec.overriding(ProcessorUtils.getMethod(this.processingEnvironment, "getInfo", GeneratorProvider.class))
                .addStatement("$T<$T> list = new $T<>()", List.class, GenerationInfo.class, ArrayList.class);
        for (GenerationResult result : value) {
            if (result.customGenerator != null) {
                builder.addStatement("list.add(new $T($S, new $L()))",
                        GenerationInfo.class, result.columnName, result.customGenerator);
            } else {
                builder.addStatement("list.add(new $T($S, $S, $S, $S, $S, $T.$L, null))",
                        GenerationInfo.class, result.columnName, result.keyColumn, result.valueColumn,
                        result.matchKey, result.tableName, ParameterConverter.class, result.matchConverter);
            }
        }

        return Arrays.asList(getEntityClass, builder.addStatement("return list").build());
    }

    private Collection<? extends GenerationResult> getCustomGenerated(RoundEnvironment roundEnvironment) {
        return roundEnvironment.getElementsAnnotatedWith(CustomGenerated.class)
                .stream()
                .map(e -> GenerationResult.fromCustom(e, this.processingEnvironment))
                .collect(Collectors.toList());
    }

    private List<GenerationResult> getTableGenerated(RoundEnvironment roundEnvironment) {
        Set<? extends Element> elementsAnnotatedWith = roundEnvironment.getElementsAnnotatedWith(TableGenerated.class);
        return elementsAnnotatedWith.stream()
                .map(GenerationResult::fromTable)
                .collect(Collectors.toList());
    }

    private static class GenerationResult {

        private TypeElement klass;
        private String tableName;
        private String keyColumn;
        private String valueColumn;
        private String matchKey;
        private ParameterConverter matchConverter;
        private TypeMirror customGenerator;
        private String columnName;

        public TypeElement getKlass() {
            return klass;
        }

        public static GenerationResult fromTable(Element element) {
            TableGenerated generated = element.getAnnotation(TableGenerated.class);
            GenerationResult result = new GenerationResult();
            result.tableName = generated.tableName();
            result.keyColumn = generated.keyColumn();
            result.valueColumn = generated.valueColumn();
            result.matchKey = generated.matchKey();
            result.matchConverter = generated.matchConverter();
            result.klass = (TypeElement) element.getEnclosingElement();
            result.columnName = element.getAnnotation(Column.class).name();
            return result;
        }

        public static GenerationResult fromCustom(Element element, ProcessingEnvironment processingEnvironment) {
            GenerationResult result = new GenerationResult();
            try {
                Class<? extends CustomGenerator<?>> value = element.getAnnotation(CustomGenerated.class).value();
                result.customGenerator = processingEnvironment.getElementUtils().getTypeElement(value.getName())
                        .asType();
            } catch (MirroredTypeException ex) {
                result.customGenerator = ex.getTypeMirror();
            }
            result.klass = (TypeElement) element.getEnclosingElement();
            result.columnName = element.getAnnotation(Column.class).name();
            return result;
        }
    }
}
